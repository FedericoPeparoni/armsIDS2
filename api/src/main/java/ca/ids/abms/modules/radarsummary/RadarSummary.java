package ca.ids.abms.modules.radarsummary;

import ca.ids.abms.config.db.SearchableText;
import ca.ids.abms.config.db.validators.UniqueKey;
import ca.ids.abms.modules.common.mappers.Time4Digits;
import ca.ids.abms.modules.util.models.VersionedAuditedEntity;
import ca.ids.abms.util.StringUtils;
import com.opencsv.bean.CsvBindByPosition;

import javax.persistence.*;
import javax.validation.constraints.Size;
import java.lang.reflect.Field;
import java.time.LocalDateTime;
import java.util.List;

/**
 * The radar summary is generated by systems such as the EUROCAT-C or Raytheon.
 * The radar summary contains the FIR entry and exit points and times for each flight.
 * Created by c.talpa on 05/01/2017.
 */
@Entity
@Table(name="radar_summaries")
@UniqueKey(columnNames = {"flightIdentifier","dayOfFlight","departureTime","departureAeroDrome","segment"})
public class RadarSummary extends VersionedAuditedEntity {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy= GenerationType.IDENTITY)
    private Integer id;

    @Column(name="date")
    @CsvBindByPosition(position = 2)
    private LocalDateTime date;

    @SearchableText
    @Column(name="flight_identifier",length = 10)
    @CsvBindByPosition(position = 1)
    @Size(min = 1, max = 10)
    private String flightIdentifier;

    @Column(name="day_of_flight")
    private LocalDateTime dayOfFlight;

    @SearchableText
    @Column(name="dep_time", length = 4)
    @Time4Digits
    @CsvBindByPosition(position = 12)
    private String departureTime;

    @SearchableText
    @Column(name="registration_number", length = 100)
    @CsvBindByPosition(position = 3)
    private String registration;

    @SearchableText
    @Column(name = "aircraft_type", length = 4)
    @CsvBindByPosition(position = 6)
    @Size(min=1,max=4)
    private String  aircraftType;

    @SearchableText
    @Column(name="dep_ad", length = 4)
    @CsvBindByPosition(position = 11)
    @Size(min=1,max=4)
    private String departureAeroDrome;

    @SearchableText
    @Column(name="dest_ad", length = 4)
    @CsvBindByPosition(position = 9)
    @Size(min=1,max=4)
    private String destinationAeroDrome;

    /**
     * Although waypoints are used for setting route text from bulk upload sources, updates from the UI
     * may overwrite route text at anytime.
     *
     * However, if another bulk upload source is added, the UI entered route text will be overwritten.
     *
     * Therefore, it is assumed that UI updated route text will only be done after all radar bulk upload
     * sources have been applied.
     */
    @Column(name="route")
    private String route;

    @SearchableText
    @Column(name="entry_point")
    @CsvBindByPosition(position = 14)
    private String firEntryPoint;

    @SearchableText
    @Column(name="entry_time",length = 4)
    @Time4Digits
    @CsvBindByPosition(position = 15)
    private String firEntryTime;

    @Column(name="entry_date")
    private LocalDateTime firEntryDate;

    @SearchableText
    @Column(name="exit_point")
    private String firExitPoint;

    @SearchableText
    @Column(name="exit_time",length = 4)
    @Time4Digits
    private String firExitTime;

    @SearchableText
    @Column(name="flight_rule",length = 10)
    @CsvBindByPosition(position = 5)
    private String flightRule;

    @Column(name="flight_travel_category",length = 20)
    @CsvBindByPosition(position = 0)
    @Enumerated(EnumType.STRING)
    private FlightTravelCategory flightTravelCategory;

    @SearchableText
    @Column(name="flight_type", length = 10)
    @CsvBindByPosition(position = 4)
    private String flightType;

    @SearchableText
    @Column(name="dest_time", length = 4)
    @Time4Digits
    @CsvBindByPosition(position = 10)
    private String destTime;

    /**
     * List of waypoints with datetime, point, and level data. Currently, these waypoints are only used
     * for reconstructing route text.
     *
     * Persisted as delimiter separated values in a similar format:
     *  `20190131:2350-WYPNT1-F360,20190201:0005-WYPNT2-F360`
     *
     * Entry is separated by `RadarSummaryConstants.WAYPOINTS_ENTRY_SEPARATOR`
     * well each value is separated by `RadarSummaryConstants.WAYPOINTS_VALUE_SEPARATOR`.
     *
     * Datetime pattern is specified by the DateTimeFormatter `RadarSummaryConstants.WAYPOINTS_DATETIME_FORMATTER`.
     */
    @Column(name = "waypoints")
    private String waypoints;

    /**
     * Same as the like-named field in flight_movements table: cruising speed prefixed with
     * K (kilometers per hour), N (knots) or M (True Mach number), e.g. "N0100".
     *
     * See also ICAO DOC 4444 about the correct syntax of this field in flight plan messages.
     *
     * NOTE: the syntax of this field is not enforced at the database level, so it may contain
     * "garbage".
     */
    @Column(length = 5)
    private String cruisingSpeed;

    /**
     * Same as the like-named field in flight_movements table, e.g. "M"
     *
     * See also ICAO DOC 4444 about the correct syntax of this field in flight plan messages.
     */
    @Column(length = 1)
    private String wakeTurb;

    /**
     * Same as the like-named field in flight_movements table. In radar_summaries, this field
     * may not follow ICAO DOC 4444 syntax.
     */
    @Column(length = 5)
    private String flightLevel;

    /**
     * Flight level of the entry point
     */
    @Column(name = "entryPointFlightLevel", length = 5)
    private String firEntryFlightLevel;

    /**
     * Leonardo file may contain multiple segments for the same flight
     */
    @Column(name = "segment")
    private Integer segment;

    /**
     * Flight level of the exit point
     */
    @Column(name = "exitPointFlightLevel", length = 5)
    private String firExitFlightLevel;

    /**
     * Coordinate of the entry point
     */
    @Column(name = "entry_coordinate")
    private String entryCoordinate;

    /**
     * Coordinate of the exit point
     */
    @Column(name = "exit_coordinate")
    private String exitCoordinate;


    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public FlightTravelCategory getFlightTravelCategory() {
        return flightTravelCategory;
    }

    public void setFlightTravelCategory(FlightTravelCategory flightTravelCategory) {
        this.flightTravelCategory = flightTravelCategory;
    }

    public String getFlightIdentifier() {
        return flightIdentifier;
    }

    public void setFlightIdentifier(String flightIdentifier) {
        this.flightIdentifier = flightIdentifier;
    }

    public LocalDateTime getDate() {
        return date;
    }

    public void setDate(LocalDateTime date) {
        this.date = date;
    }

    public String getRegistration() {
        return registration;
    }

    public void setRegistration(String registration) {
        registration = StringUtils.strip(registration);

        if(StringUtils.isNotBlank(registration)) {
            this.registration = registration.split(StringUtils.WHITE_SPACE_REGEX)[0];
        } else {
            this.registration = null;
        }
    }

    public String getFlightType() {
        return flightType;
    }

    public void setFlightType(String flightType) {
        this.flightType = flightType;
    }

    public String getFlightRule() {
        return flightRule;
    }

    public void setFlightRule(String flightRule) {
        this.flightRule = flightRule;
    }

    public String getAircraftType() {
        return aircraftType;
    }

    public void setAircraftType(String aircraftType) {
        this.aircraftType = aircraftType;
    }

    public LocalDateTime getDayOfFlight() {
        return dayOfFlight;
    }

    public void setDayOfFlight(LocalDateTime dayOfFlight) {
        this.dayOfFlight = dayOfFlight;
    }

    public String getRoute() {
        return route;
    }

    public void setRoute(String route) {
        this.route = route;
    }

    public String getDestinationAeroDrome() {
        return destinationAeroDrome;
    }

    public void setDestinationAeroDrome(String destinationAeroDrome) {
        this.destinationAeroDrome = destinationAeroDrome;
    }

    public String getDestTime() {
        return destTime;
    }

    public void setDestTime(String destTime) {
        this.destTime = destTime;
    }

    public String getDepartureAeroDrome() {
        return departureAeroDrome;
    }

    public void setDepartureAeroDrome(String departureAeroDrome) {
        this.departureAeroDrome = departureAeroDrome;
    }

    public String getDepartureTime() {
        return departureTime;
    }

    public void setDepartureTime(String departureTime) {
        this.departureTime = departureTime;
    }

    public String getFirEntryPoint() {
        return firEntryPoint;
    }

    public void setFirEntryPoint(String firEntryPoint) {
        this.firEntryPoint = firEntryPoint;
    }

    public String getFirEntryTime() {
        return firEntryTime;
    }

    public void setFirEntryTime(String firEntryTime) {
        this.firEntryTime = firEntryTime;
    }

    public LocalDateTime getFirEntryDate() {
        return firEntryDate;
    }

    public void setFirEntryDate(LocalDateTime firEntryDate) {
        this.firEntryDate = firEntryDate;
    }

    public String getFirExitPoint() {
        return firExitPoint;
    }

    public void setFirExitPoint(String firExitPoint) {
        this.firExitPoint = firExitPoint;
    }

    public String getFirExitTime() {
        return firExitTime;
    }

    public void setFirExitTime(String firExitTime) {
        this.firExitTime = firExitTime;
    }

    public List<RadarSummaryWaypoint> getWaypoints() {
        return RadarSummaryWaypointFormatter.parse(waypoints);
    }

    public void setWaypoints(final List<RadarSummaryWaypoint> waypoints) {
        this.waypoints = RadarSummaryWaypointFormatter.format(waypoints);
    }

    public String getCruisingSpeed() {
        return cruisingSpeed;
    }

    public void setCruisingSpeed(String cruisingSpeed) {
        this.cruisingSpeed = cruisingSpeed;
    }

    public String getWakeTurb() {
        return wakeTurb;
    }

    public void setWakeTurb(String wakeTurb) {
        this.wakeTurb = wakeTurb;
    }

    public String getFirEntryFlightLevel() {
        return firEntryFlightLevel;
    }

    public void setFirEntryFlightLevel(String firEntryFlightLevel) {
        this.firEntryFlightLevel = firEntryFlightLevel;
    }

    public String getFirExitFlightLevel() {
        return firExitFlightLevel;
    }

    public void setFirExitFlightLevel(String firExitFlightLevel) {
        this.firExitFlightLevel = firExitFlightLevel;
    }

    public Integer getSegment() {
        return segment;
    }

    public void setSegment(Integer segment) {
        this.segment = segment;
    }

    public String getEntryCoordinate() {
        return entryCoordinate;
    }

    public void setEntryCoordinate(String entryCoordinate) {
        this.entryCoordinate = entryCoordinate;
    }

    public String getExitCoordinate() {
        return exitCoordinate;
    }

    public void setExitCoordinate(String exitCoordinate) {
        this.exitCoordinate = exitCoordinate;
    }

    public String getFlightLevel() {
        return flightLevel;
    }

    public void setFlightLevel(String flightLevel) {
        this.flightLevel = flightLevel;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        RadarSummary that = (RadarSummary) o;

        return id != null ? id.equals(that.id) : that.id == null;

    }

    @Override
    public int hashCode() {
        int result = id != null ? id.hashCode() : 0;
        result = 31 * result + (flightIdentifier != null ? flightIdentifier.hashCode() : 0);
        result = 31 * result + (dayOfFlight != null ? dayOfFlight.hashCode() : 0);
        result = 31 * result + (departureTime != null ? departureTime.hashCode() : 0);
        result = 31 * result + (departureAeroDrome != null ? departureAeroDrome.hashCode() : 0);
        result = 31 * result + (segment != null ? segment.hashCode() : 0);
        return result;
    }

    @Override
    public String toString() {
        return "RadarSummary{" +
            "flightTravelCategory='" + flightTravelCategory + '\'' +
            ", flightIdentifier='" + flightIdentifier + '\'' +
            ", date=" + date +
            ", registration='" + registration + '\'' +
            ", flightType='" + flightType + '\'' +
            ", flightRule='" + flightRule + '\'' +
            ", aircraftType='" + aircraftType + '\'' +
            ", dayOfFlight=" + dayOfFlight +
            ", route='" + route + '\'' +
            ", destinationAeroDrome='" + destinationAeroDrome + '\'' +
            ", destTime='" + destTime + '\'' +
            ", departureAeroDrome='" + departureAeroDrome + '\'' +
            ", departureTime='" + departureTime + '\'' +
            ", firEntryPoint='" + firEntryPoint + '\'' +
            ", firEntryTime='" + firEntryTime + '\'' +
            ", firExitPoint='" + firExitPoint + '\'' +
            ", firExitTime='" + firExitTime + '\'' +
            ", segment='" + segment + '\'' +
            '}';
    }


    public Boolean isValid(){

        Boolean returnValue=Boolean.TRUE;

        if (!StringUtils.isNotBlank(this.getDepartureAeroDrome())) {

            returnValue = Boolean.FALSE;
        }

        if (!StringUtils.isNotBlank(this.getDestinationAeroDrome())) {

            returnValue = Boolean.FALSE;
        }

        if (!StringUtils.isNotBlank(this.getDepartureTime())) {
            returnValue = Boolean.FALSE;
        }

        if (!StringUtils.isNotBlank(this.getFlightIdentifier()) ) {
            returnValue = Boolean.FALSE;
        }

        if (this.getDate() == null) {
            returnValue = Boolean.FALSE;
        }

        if (this.getSegment() == null) {
            returnValue = Boolean.FALSE;
        }
        return returnValue;

    }

    /**
     * Compares fields of existing radar summary and incoming radar summary
     *
     * @param newRadarSummary to be checked;
     * @return boolean representing if matching records;
     */
    public Boolean isDuplicate(RadarSummary newRadarSummary) {
        Field[] fields = RadarSummary.class.getDeclaredFields();

        for (Field field : fields) {
            field.setAccessible(true);

            try {
                // skip ID field and fields where both are null
                if (field.getName().equalsIgnoreCase("id")
                    || field.get(newRadarSummary) == null && field.get(this) == null) {
                    continue;
                }

                // check for null equality
                if (field.get(newRadarSummary) == null && field.get(this) != null
                    || field.get(newRadarSummary) != null && field.get(this) == null) {
                    return false;
                }

                // item is not a duplicate if fields do not match
                if (!field.get(this).equals(field.get(newRadarSummary))) {
                    return false;
                }
            } catch (IllegalAccessException e) {
                return false;
            }
        }

        // item is a duplicate
        return true;
    }

    @Transient
    public String getDisplayName() {
        final LocalDateTime dof = getDayOfFlight();
        return String.format ("RadarSummary {flgihtId=%s, dayOfFlight=%s, departureAerodrome=%s}",
            getFlightIdentifier(), dof == null ? null : dof.toLocalDate().toString(), getDepartureAeroDrome());
    }

}

